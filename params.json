{
  "name": "Рекуррент харьцаа ба матриц",
  "tagline": "Алгоритм, Математик, Программ",
  "body": "#Рекуррент харьцаа ба матриц\r\n\r\nРекуррент харьцаагаар өгөгдсөн шугаман тэгшитгэлийг/ `F(n) = A*F(n-1) + B*F(n-2)` / бид нар бодохдоо динамик програмчлалын арга ашиглаж боддог. \r\n```C++\r\nint F(int A,int B, int N){\r\n    vector< int > F[N+1];\r\n    F[1] = 1;\r\n    F[2] = 2;\r\n    for (int i=3; i<=N;){\r\n        F[i] = A*F[i-1] + B*F[i-2];\r\n    }\r\n    return F[N];\r\n}\r\n```\r\nЭнэ нь `N`-р гишүүнийг олоход `O(N)` хугацаа зарцуулдаг. Гэвч зарим тохиолдолд бид `LogN`-р бодох шаардлага гарч ирдэг.\r\n\r\nБид нар шугаман рекуррент тэгшитгэлийг `X(i+1) = M X(i)` хэлбэртэй бичиж болно. \r\nҮүнд:\r\n`X(i+1)` болон `X(i)` нь `1 x K` хэмжээтэй матриц. `M` нь `K x K`хэмжээтэй матриц.\r\n```\r\n| f(n+1)   |       | f(n)   |\r\n|  f(n)    |       | f(n-1) |\r\n| f(n-1)   | = M x | f(n-2) |\r\n| ......   |       | ...... |\r\n| f(n-k+1) |       | f(n-k) |\r\n```\r\nЭндээс бид нар рекуррент харьцаагаа ашиглаад `M` матрицаа олно.\r\n\r\n###1. Хамгийн энгийн рекуррент харьцаа болох Фиббоначийн дараалалыг авч үзье.\r\n```\r\nf(n) = f(n-1) + f(n-2) => f(n+1) = f(n) + f(n-1) ингэж бичиж болно.\r\n```\r\nТэгвэл `X(i+1)` болон `X(i)` матрицууд дараах байдлаар бичигдэнэ.\r\n```\r\n| f(n+1) | = M x | f(n)   | => | f(n+1) | = | a b | x | f(n)   |\r\n| f(n)   |       | f(n-1) |    | f(n)   |   | c d |   | f(n-1) |\r\n```\r\nЭндээс харахад бидний `K` тоо буюу матрицын хэмжээ нь тухайн харьцаа өөрөөсөө өмнөх хэдэн гишүүнээсээ хамааралтай байна гэдгээс олж болох нь харагдаж байна. Фиббаночийн хувьд өмнөх 2 гишүүнээсээ хамаардаг тул матрицын хэмжээ `K=2`.\r\n\r\nОдоо `М` матрицыг олъё. Дээрх `M` болон `X(i-1)` матрицыг үржвэл:\r\n```\r\na*f(n) + b*f(n-1) = f(n+1) \r\nc*f(n) + d*f(n-1) = f(n)\r\n```\r\nФиббоначийн дараалалын эхний 3-н гишүүнийг мэдэх учир орлуулаад a=1, b=1, c=1, d=0 гэж гарна. \r\nОдоо бид М-г мэдэх учраас дараах байдлаар бичиж болно.\r\n```\r\n| f(n+1) | = | 1 1 | x | f(n)   |\r\n| f(n)   |   | 1 0 |   | f(n-1) |\r\n```\r\n```\r\n| ? | = | 1 1 | x | 8 |\r\n| 8 |   | 1 0 |   | 5 |\r\n````\r\n`?` => `8*1 + 5*1 = 13`\r\n\r\n\r\n<img src=\"http://i.imgur.com/iQ802FF.png\"/>\r\n\r\n###2. `f(n) = a * f(n-1) + c * f(n-3) + d * f(n-4) + e` тэгшитгэлийн хувьд марицыг олъё.\r\n\r\n```\r\n| a  0  c  d  1 |   |  f(n)  |   | f(n+1) |\r\n| 1  0  0  0  0 |   | f(n-1) |   |  f(n)  |\r\n| 0  1  0  0  0 | x | f(n-2) |   | f(n-1) |\r\n| 0  0  1  0  0 |   | f(n-3) |   | f(n-2) |\r\n| 0  0  0  0  1 |   |   c    |   |   c    |\r\n\r\n```\r\n\r\n### Анализ\r\n\r\nДараах рекуррентийн хувьд авч үзье: `f(n) = f(n-1) + f(n-2)`.\r\n```\r\nM x |  f(n)  | = | f(n+1) |\r\n    | f(n-1) |   |  f(n)  |\r\n```\r\nТэгшитгэлийн 2 талыг `M`-р үржье\r\n```\r\nM x M x |  f(n)  | = M x | f(n+1) | = | f(n+2) |\r\n        | f(n-1) |       |  f(n)  |   | f(n+1) |\r\n```\r\nЭмхэтгэвэл:\r\n```\r\nM^2 x |  f(n)  | = | f(n+2) |\r\n      | f(n-1) |   | f(n+1) |\r\n```\r\nДараах байдалтай болох нь харагдаж байна.\r\n```\r\nM^3 x |  f(n)  | = | f(n+3) |\r\n      | f(n-1) |   | f(n+2) |\r\n```\r\n\r\n```\r\nM^4 x |  f(n)  | = | f(n+4) |\r\n      | f(n-1) |   | f(n+3) |\r\n\r\n...............................\r\n...............................\r\n...............................\r\n\r\nM^k x |  f(n)  | = | f(n+k) |\r\n      | f(n-1) |   |f(n+k-1)|\r\n```\r\n\r\n`X(i+k) = M^k * X(i)` Бид нар 2 матрицыг `O(N^3)`-д үржнэ. \r\n```C++\r\nconst Matrix Matrix::operator*(const Matrix &A){\r\n    Matrix C(A.N);\r\n    for( int i = 0; i < A.N; ++i )\r\n        for( int j = 0; j < A.N; ++j ){\r\n            for( int k = 0; k < A.N; ++k )\r\n                C.data[i][j] = (C.data[i][j] + data[i][k] * A.data[k][j])%MOD;\r\n        }\r\n    return C;\r\n}\r\n```\r\nТэгвэл `К` зэргийг шугаман олвол O(N^3*K). \r\n```C++\r\nint naive_power(int a, int k):\r\n    int res = 1;\r\n    for (int i=1; i<=k; i++){\r\n        res *= a\r\n    }\r\n    return res;\r\n```\r\nХэрвээ `К` зэргийг `Log`-д олж чадвал `O(N^3*LogK)` болно. \r\n\r\n###Хуваагаад нэгтгэх аргаар зэргийг `O(LogN)`-д олох.\r\n\r\n`2^5`-г дараах байдалтай задлая.\r\n\r\n<img src=\"http://www.ideserve.co.in/learn/img/powerRecursive_1.gif\"/>\r\n\r\nЭндээс дараах байдалтай харагдана.\r\n\r\n<img src=\"http://www.cs.cornell.edu/courses/cs3110/2012sp/lectures/lec20-master/images/lec19-diagram1.png\"/>\r\n\r\nХугацааны үнэлгээ нь модны өндөртэй тэнцүү.\r\n\r\n<img src=\"http://i.stack.imgur.com/rcaOC.png\"/>\r\n\r\n\r\n```C++\r\nint power(int n, int k){\r\n    if(k==0)return 1;\r\n    if(k==1)return n;\r\n    int tmp = power(n, k/2);\r\n    if(k & 1) \r\n        return tmp*tmp*n;\r\n    else \r\n        return tmp*tmp;\r\n}\r\n```\r\n\r\n```C++\r\nint ipow(int base, int exp){\r\n    int result = 1;\r\n    while (exp){\r\n        if (exp & 1)\r\n            result *= base;\r\n        exp >>= 1;\r\n        base *= base;\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n### Матрицын C++ хэл дээрх код\r\n```C++\r\n#include <vector>\r\n#include <iostream>\r\n\r\nint MOD = 1000000007;\r\nusing namespace std;\r\n\r\nclass Matrix{\r\n    public:\r\n        int N; \r\n        vector< vector< long long > > data; \r\n\r\n        Matrix(int N);\r\n        Matrix(const Matrix &matrix);\r\n\r\n        const Matrix &operator=(const Matrix &A);\r\n        const Matrix operator*(const Matrix &A); \r\n        const Matrix operator^(int P );\r\n\r\n        ~Matrix(); \r\n};\r\n\r\nMatrix::Matrix(int N){\r\n    this->N = N;\r\n    data = vector< vector< long long > >(N, vector< long long >(N));\r\n}\r\n\r\nMatrix::Matrix(const Matrix &A){\r\n    this->N = A.N;\r\n    data = vector< vector< long long > >(A.data);\r\n}\r\nMatrix::~Matrix(){\r\n    data.clear();\r\n}\r\n\r\nconst Matrix &Matrix::operator=(const Matrix &A){\r\n    if( &A != this ){\r\n        data.clear();\r\n        N = A.N;\r\n        data = vector< vector< long long > >(A.data);\r\n    }\r\n    return *this;\r\n}\r\nconst Matrix Matrix::operator*(const Matrix &A){\r\n    Matrix C(A.N);\r\n    for( int i = 0; i < A.N; ++i )\r\n        for( int j = 0; j < A.N; ++j ){\r\n            for( int k = 0; k < A.N; ++k )\r\n                C.data[i][j] = (C.data[i][j] + data[i][k] * A.data[k][j])%MOD;\r\n        }\r\n    return C;\r\n}\r\n\r\nconst Matrix Matrix::operator^(int P){\r\n    if(P == 1) return (*this);\r\n    if(P & 1) return ((*this) * ((*this) ^ (P-1)));\r\n    Matrix B = ((*this) ^ (P/2));\r\n    return (B*B);\r\n}\r\n\r\nlong long value(Matrix &matrix,int P,vector< int > &def){\r\n    if (P <= def.size())\r\n        return def[P-1];\r\n    Matrix res = matrix^(P-def.size());\r\n    int val = 0;\r\n    for (int i=0,t = def.size()-1; i<res.data[0].size(); i++,t--){\r\n    \tval = (val + (res.data[0][i] * def[t])%MOD)%MOD;\r\n    }\r\n    return val;\r\n}\r\n\r\nint main(){\r\n\r\n    vector< int > def = {4,14};\r\n\r\n    Matrix matrix(2);\r\n    matrix.data[0][0] = 3; matrix.data[0][1] = 2;\r\n    matrix.data[1][0] = 1; matrix.data[1][1] = 0;\r\n\r\n    int t;\r\n    cin>>t;\r\n    while (t--){\r\n        int n;\r\n        cin>>n;\r\n        cout<<value(matrix,n,def)<<endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n### Бодох бодлогууд\r\n1. <a href=\"http://www.spoj.com/CSMS/problems/MSR10_04/\"> Үг </a><br>\r\n2. <a href=\"http://www.spoj.com/CSMS/problems/TSEREG/\"> Цэрэг </a><br>\r\n3. <a href=\"https://uva.onlinejudge.org/external/108/p10870.pdf\"> UVa 10870 : Recurrences </a><br>\r\n4. <a href=\"https://uva.onlinejudge.org/external/115/p11551.pdf\"> UVa 11551 : Experienced Endeavour </a><br>\r\n5. <a href=\"http://www.spoj.com/CSMS/problems/NEIGH/\"> Хөршүүд </a>\r\n\r\n###Холбоос\r\n1. http://zobayer.blogspot.com/2010/11/matrix-exponentiation.html\r\n2. https://www.topcoder.com/tc?module=Static&d1=features&d2=010408\r\n3. http://fusharblog.com/solving-linear-recurrence-for-programming-contest/\r\n4. https://comeoncodeon.wordpress.com/2011/05/08/recurrence-relation-and-matrix-exponentiation/",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}